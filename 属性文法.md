# 属性文法（严格按文法.md；语义动作与 rd_parser.py 对齐）

说明
1）本项目三地址码输出为四元式：emit(op, arg1, arg2, result)，并使用 label / goto / ifFalse 表达控制流。
2）本版本完全按文法.md 的 1~28 号产生式编写；不再使用 backpatch/nextlist 那套（代码实现也没用）。
3）表达式采用“Tail 继承属性”实现左结合，写出来的动作形式和你要的
   AddExpr→AddExpr - MulExpr { t=newtemp(); emit('-',...); ... }
   等价，只是挂在 AddTail/MulTail/RelTail 上实现（符合 LL(1) 文法）。
4）for 的 cond/iter 按你的 _DeferredEmitter 思路：先解析缓冲 code，后在正确位置 flush。


0. 记号与公共属性

终结符属性
- IDENT：记为 id，属性 id.lexeme
- NUM：记为 num，属性 num.lexeme

表达式类非终结符综合属性（Synthesized）
- X.place：值所在位置（变量名/常量/临时变量）
- X.typ：类型（char/int/float/double）

Tail 非终结符采用继承属性（Inherited）携带“当前累计值”
- RelTail.in_place / RelTail.in_typ，综合：RelTail.place / RelTail.typ
- AddTail.in_place / AddTail.in_typ，综合：AddTail.place / AddTail.typ
- MulTail.in_place / MulTail.in_typ，综合：MulTail.place / MulTail.typ

for 可选段（为了表达 DeferredEmitter 的缓冲）
- ForCondOpt.has，ForCondOpt.place，ForCondOpt.code
- ForIterOpt.code


1. 语义辅助过程（与代码一致/等价）

- declare(name, typ) -> bool
- lookup_type(name) -> typ | None
- sem_error(tok, message, symbol)
- enter_scope() / exit_scope()
- newtemp() / newlabel()
- emit(op, a1, a2, res)
- emit_label(L)
- emit_goto(L)
- emit_ifFalse(cond_place, L)
- emit_all(code_list)   // flush 缓冲四元式序列

- promote(t1, t2)
- is_numeric(t)
- is_assignable(dst, src)  // 只允许“拓宽”赋值


2. 产生式与语义动作（对应 文法.md）


（1）Program -> StmtList EOF

Program→StmtList EOF
{
	// StmtList 过程中已产生 TAC；此处仅匹配 EOF
}


（2）StmtList -> Stmt StmtList | ε

StmtList→Stmt StmtList
{
	// 顺序执行；不做 nextlist/backpatch
}

StmtList→ε
{
}


（3）Stmt -> ForStmt | Block | DeclStmt ';' | ';' | PrefixIncDec ';' | IDENT IdStmtTail ';'

Stmt→ForStmt
{
}

Stmt→Block
{
}

Stmt→DeclStmt ;
{
}

Stmt→;
{
}

Stmt→PrefixIncDec ;
{
}

Stmt→id IdStmtTail ;
{
}


（4）Block -> '{' StmtList '}'

Block→{ StmtList }
{
	enter_scope();
	// 解析执行 StmtList
	exit_scope();
}


（5）ForStmt -> 'for' '(' ForInitOpt ';' ForCondOpt ';' ForIterOpt ')' Stmt

ForStmt→for ( ForInitOpt ; ForCondOpt ; ForIterOpt ) Stmt
{
	L_begin = newlabel();
	L_end   = newlabel();

	emit_label(L_begin);

	if (ForCondOpt.has == true) {
		emit_all(ForCondOpt.code);
		emit_ifFalse(ForCondOpt.place, L_end);
	}

	// 循环体
	// Stmt 已完成 emit

	// 迭代段在循环体之后
	emit_all(ForIterOpt.code);

	emit_goto(L_begin);
	emit_label(L_end);
}


（6）ForInitOpt -> DeclStmt | PrefixIncDec | IDENT ForIdTail | ε

ForInitOpt→DeclStmt
{
}

ForInitOpt→PrefixIncDec
{
}

ForInitOpt→id ForIdTail
{
}

ForInitOpt→ε
{
}


（7）ForCondOpt -> Expr | ε

ForCondOpt→Expr
{
	ForCondOpt.has   = true;
	ForCondOpt.place = Expr.place;
	ForCondOpt.code  = Expr.code;     // 表达“缓冲”，等价于 DeferredEmitter
}

ForCondOpt→ε
{
	ForCondOpt.has  = false;
	ForCondOpt.code = [ ];
}


（8）ForIterOpt -> PrefixIncDec | IDENT ForIdTail | ε

ForIterOpt→PrefixIncDec
{
	ForIterOpt.code = PrefixIncDec.code;   // 缓冲
}

ForIterOpt→id ForIdTail
{
	ForIterOpt.code = ForIdTail.code;      // 缓冲
}

ForIterOpt→ε
{
	ForIterOpt.code = [ ];
}


（9）DeclStmt -> Type IDENT DeclInitOpt

DeclStmt→Type id DeclInitOpt
{
	ok = declare(id.lexeme, Type.lexeme);
	if (ok == false) sem_error(id, "重复声明标识符", id.lexeme);

	if (DeclInitOpt.has == true) {
		if (is_assignable(Type.lexeme, DeclInitOpt.expr.typ) == false) {
			sem_error(id, "类型不兼容：无法将 " + DeclInitOpt.expr.typ + " 赋值给 " + Type.lexeme, id.lexeme);
		}
		emit("=", DeclInitOpt.expr.place, "", id.lexeme);
	}
}


（10）Type -> 'int' | 'float' | 'double' | 'char'

Type→int    { Type.lexeme = "int"; }
Type→float  { Type.lexeme = "float"; }
Type→double { Type.lexeme = "double"; }
Type→char   { Type.lexeme = "char"; }


（11）DeclInitOpt -> '=' Expr | ε

DeclInitOpt→= Expr
{
	DeclInitOpt.has  = true;
	DeclInitOpt.expr = Expr;
}

DeclInitOpt→ε
{
	DeclInitOpt.has = false;
}


（12）AssignOp -> '=' | '+=' | '-=' | '*=' | '/='

AssignOp→=   { AssignOp.lexeme = "="; }
AssignOp→+=  { AssignOp.lexeme = "+="; }
AssignOp→-=  { AssignOp.lexeme = "-="; }
AssignOp→*=  { AssignOp.lexeme = "*="; }
AssignOp→/=  { AssignOp.lexeme = "/="; }


（13）IncDecOp -> '++' | '--'

IncDecOp→++ { IncDecOp.lexeme = "++"; }
IncDecOp→-- { IncDecOp.lexeme = "--"; }


（14）PrefixIncDec -> IncDecOp IDENT

PrefixIncDec→IncDecOp id
{
	lhs_typ = lookup_type(id.lexeme);
	if (lhs_typ == None) sem_error(id, "使用了未声明的标识符", id.lexeme);
	else if (is_numeric(lhs_typ) == false) sem_error(id, "自增/自减要求数值类型", id.lexeme);

	t = newtemp();
	if (IncDecOp.lexeme == "++") emit("+", id.lexeme, "1", t);
	else                        emit("-", id.lexeme, "1", t);
	emit("=", t, "", id.lexeme);
}


（15）IdStmtTail -> IncDecOp | AssignOp Expr

IdStmtTail→IncDecOp
{
	lhs_typ = lookup_type(id.lexeme);
	if (lhs_typ == None) sem_error(id, "使用了未声明的标识符", id.lexeme);
	else if (is_numeric(lhs_typ) == false) sem_error(id, "自增/自减要求数值类型", id.lexeme);

	t = newtemp();
	if (IncDecOp.lexeme == "++") emit("+", id.lexeme, "1", t);
	else                        emit("-", id.lexeme, "1", t);
	emit("=", t, "", id.lexeme);
}

IdStmtTail→AssignOp Expr
{
	lhs_typ = lookup_type(id.lexeme);
	if (lhs_typ == None) {
		sem_error(id, "使用了未声明的标识符", id.lexeme);
		lhs_typ = "int";
	}

	if (AssignOp.lexeme == "=") {
		if (is_assignable(lhs_typ, Expr.typ) == false) {
			sem_error(id, "类型不兼容：无法将 " + Expr.typ + " 赋值给 " + lhs_typ, id.lexeme);
		}
		emit("=", Expr.place, "", id.lexeme);
	} else {
		if (!(is_numeric(lhs_typ) && is_numeric(Expr.typ))) {
			sem_error(AssignOp, "复合赋值运算要求数值类型", AssignOp.lexeme);
		}

		t = newtemp();
		op = (AssignOp.lexeme == "+=") ? "+" :
			 (AssignOp.lexeme == "-=") ? "-" :
			 (AssignOp.lexeme == "*=") ? "*" : "/";

		emit(op, id.lexeme, Expr.place, t);
		emit("=", t, "", id.lexeme);
	}
}


（16）ForIdTail -> IncDecOp | AssignOp Expr（语义同 IdStmtTail）

ForIdTail→IncDecOp
{
	lhs_typ = lookup_type(id.lexeme);
	if (lhs_typ == None) sem_error(id, "使用了未声明的标识符", id.lexeme);
	else if (is_numeric(lhs_typ) == false) sem_error(id, "自增/自减要求数值类型", id.lexeme);

	t = newtemp();
	if (IncDecOp.lexeme == "++") emit("+", id.lexeme, "1", t);
	else                        emit("-", id.lexeme, "1", t);
	emit("=", t, "", id.lexeme);
}

ForIdTail→AssignOp Expr
{
	lhs_typ = lookup_type(id.lexeme);
	if (lhs_typ == None) {
		sem_error(id, "使用了未声明的标识符", id.lexeme);
		lhs_typ = "int";
	}

	if (AssignOp.lexeme == "=") {
		if (is_assignable(lhs_typ, Expr.typ) == false) {
			sem_error(id, "类型不兼容：无法将 " + Expr.typ + " 赋值给 " + lhs_typ, id.lexeme);
		}
		emit("=", Expr.place, "", id.lexeme);
	} else {
		if (!(is_numeric(lhs_typ) && is_numeric(Expr.typ))) {
			sem_error(AssignOp, "复合赋值运算要求数值类型", AssignOp.lexeme);
		}

		t = newtemp();
		op = (AssignOp.lexeme == "+=") ? "+" :
			 (AssignOp.lexeme == "-=") ? "-" :
			 (AssignOp.lexeme == "*=") ? "*" : "/";

		emit(op, id.lexeme, Expr.place, t);
		emit("=", t, "", id.lexeme);
	}
}


（17）Expr -> AddExpr RelTail

Expr→AddExpr RelTail
{
	RelTail.in_place = AddExpr.place;
	RelTail.in_typ   = AddExpr.typ;

	Expr.place = RelTail.place;
	Expr.typ   = RelTail.typ;
}


（18）RelTail -> RelOp AddExpr RelTail | ε

RelTail→RelOp AddExpr RelTail1
{
	t = newtemp();
	emit(RelOp.lexeme, RelTail.in_place, AddExpr.place, t);

	RelTail1.in_place = t;
	RelTail1.in_typ   = "int";

	RelTail.place = RelTail1.place;
	RelTail.typ   = RelTail1.typ;
}

RelTail→ε
{
	RelTail.place = RelTail.in_place;
	RelTail.typ   = RelTail.in_typ;
}


（19）RelOp -> '<' | '<=' | '>' | '>=' | '==' | '!='

RelOp→<  { RelOp.lexeme = "<"; }
RelOp→<= { RelOp.lexeme = "<="; }
RelOp→>  { RelOp.lexeme = ">"; }
RelOp→>= { RelOp.lexeme = ">="; }
RelOp→== { RelOp.lexeme = "=="; }
RelOp→!= { RelOp.lexeme = "!="; }


（20）AddExpr -> MulExpr AddTail

AddExpr→MulExpr AddTail
{
	AddTail.in_place = MulExpr.place;
	AddTail.in_typ   = MulExpr.typ;

	AddExpr.place = AddTail.place;
	AddExpr.typ   = AddTail.typ;
}


（21）AddTail -> AddOp MulExpr AddTail | ε

AddTail→AddOp MulExpr AddTail1
{
	if (!(is_numeric(AddTail.in_typ) && is_numeric(MulExpr.typ))) {
		sem_error(AddOp, "算术运算要求数值类型", AddOp.lexeme);
	}

	t = newtemp();
	emit(AddOp.lexeme, AddTail.in_place, MulExpr.place, t);

	AddTail1.in_place = t;
	AddTail1.in_typ   = promote(AddTail.in_typ, MulExpr.typ);

	AddTail.place = AddTail1.place;
	AddTail.typ   = AddTail1.typ;
}

AddTail→ε
{
	AddTail.place = AddTail.in_place;
	AddTail.typ   = AddTail.in_typ;
}


（22）AddOp -> '+' | '-'

AddOp→+ { AddOp.lexeme = "+"; }
AddOp→- { AddOp.lexeme = "-"; }


（23）MulExpr -> Unary MulTail

MulExpr→Unary MulTail
{
	MulTail.in_place = Unary.place;
	MulTail.in_typ   = Unary.typ;

	MulExpr.place = MulTail.place;
	MulExpr.typ   = MulTail.typ;
}


（24）MulTail -> MulOp Unary MulTail | ε

MulTail→MulOp Unary MulTail1
{
	if (!(is_numeric(MulTail.in_typ) && is_numeric(Unary.typ))) {
		sem_error(MulOp, "算术运算要求数值类型", MulOp.lexeme);
	}

	t = newtemp();
	emit(MulOp.lexeme, MulTail.in_place, Unary.place, t);

	MulTail1.in_place = t;
	MulTail1.in_typ   = promote(MulTail.in_typ, Unary.typ);

	MulTail.place = MulTail1.place;
	MulTail.typ   = MulTail1.typ;
}

MulTail→ε
{
	MulTail.place = MulTail.in_place;
	MulTail.typ   = MulTail.in_typ;
}


（25）MulOp -> '*' | '/'

MulOp→* { MulOp.lexeme = "*"; }
MulOp→/ { MulOp.lexeme = "/"; }


（26）Unary -> UnaryOp Unary | Primary

Unary→Primary
{
	Unary.place = Primary.place;
	Unary.typ   = Primary.typ;
}

Unary→UnaryOp Unary1
{
	if (UnaryOp.lexeme == "+") {
		Unary.place = Unary1.place;
		Unary.typ   = Unary1.typ;
	}
	else if (UnaryOp.lexeme == "-") {
		if (is_numeric(Unary1.typ) == false) sem_error(UnaryOp, "一元负号要求数值类型", "-");
		t = newtemp();
		emit("-", "0", Unary1.place, t);
		Unary.place = t;
		Unary.typ   = Unary1.typ;
	}
	else {
		t = newtemp();
		emit("!", Unary1.place, "", t);
		Unary.place = t;
		Unary.typ   = "int";
	}
}


（27）UnaryOp -> '+' | '-' | '!'

UnaryOp→+ { UnaryOp.lexeme = "+"; }
UnaryOp→- { UnaryOp.lexeme = "-"; }
UnaryOp→! { UnaryOp.lexeme = "!"; }


（28）Primary -> IDENT | NUM | '(' Expr ')'

Primary→id
{
	Primary.place = id.lexeme;

	typ = lookup_type(id.lexeme);
	if (typ == None) {
		sem_error(id, "使用了未声明的标识符", id.lexeme);
		typ = "int";
	}
	Primary.typ = typ;
}

Primary→num
{
	Primary.place = num.lexeme;
	if (num.lexeme contains ".") Primary.typ = "float";
	else                         Primary.typ = "int";
}

Primary→( Expr )
{
	Primary.place = Expr.place;
	Primary.typ   = Expr.typ;
}
