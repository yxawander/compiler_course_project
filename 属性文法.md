## 属性文法 / 语法制导定义（SDD / SDT）

> 本项目中表达式/语句的核心语义就是：
>
> * 计算表达式结果保存到一个“地址/临时变量”里（`place`）
> * 产生四元式（或三地址码）到 `emitter`

### 约定

**符号属性**

* 对表达式相关非终结符：
  * `X.place`：综合属性（synthesized），表示该子表达式计算结果所在的位置（变量名或临时变量名）。
* 对尾部递归非终结符（`RelTail / AddTail / MulTail`）：
  * `Tail.in`：继承属性（inherited），表示“到目前为止已计算出的左值 place”。
  * `Tail.place`：综合属性，表示该 Tail 链完成后最终的 place。

> 记号说明：本文中出现的 `RelTail1 / AddTail1 / MulTail1`（以及类似的 `...1`）只是为了在语义动作里区分“当前 Tail”与“剩余 Tail”，它们本质上仍表示同一个非终结符（即右递归展开后的下一段 Tail）。

**语义例程（与代码同名/同含义）**

* `new_temp()` / `newtemp()`：生成临时变量（对应 `TACEmitter.new_temp()`）
* `new_label()` / `newlabel()`：生成标签（对应 `TACEmitter.new_label()`）
* `emit(op, a1, a2, res)`：输出四元式（对应 `TACEmitter.emit()`）
* `emit_label(L)`：输出标签（对应 `emit("label", result=L)`）
* `emit_goto(L)`：无条件跳转（对应 `emit("goto", result=L)`）
* `emit_if_false(cond_place, L)`：条件为假则跳转（对应 `TACEmitter.emit_if_false()` / `_DeferredEmitter.emit_if_false()`）

> 记号约定：在本文的伪代码里，四元式 `emit(op, a1, a2, res)` 的“空参数”有时写作空串 `''`，有时写作占位符 `_`；两者都表示“该位置不使用”。

> 说明：你的 `for` 在解析括号内部时用 `_DeferredEmitter` 做了“先缓冲、后 flush”的技巧。
>
>> 属性文法这里不描述缓冲细节，只描述**最终中间代码的执行顺序**，与输出结果一致。
>>

补充（对应实现细节，便于读代码）：

* `ForCondOpt` 的 `Expr` 在语法上出现在 `;` 之前，但代码生成会先缓冲到 `_DeferredEmitter`（cond_buf），在 `L_begin` 之后每轮循环开头再 `flush_to_parent()`。
* `ForIterOpt` 同理会缓冲到 `_DeferredEmitter`（iter_buf），在循环体 `Stmt` 之后再 flush。

---

### 声明语句

1) `DeclStmt → Type id DeclInitOpt`

```
{
    // DeclInitOpt 的动作见其产生式
}
```

2) `DeclInitOpt → = Expr`

```
{
    emit('=', Expr.place, _, id.lexeme);
}
```

3) `DeclInitOpt → ε`

```
{
    // no-op
}
```

---

### 语句（Stmt：统一用“产生式 + 语义动作”）

> 说明：实际实现里 `AssignStmt/IncDec/DeclStmt` 都是“语句级”入口；这里把它们写成教科书式 SDD。

4) `Stmt → ForStmt`

```
{
  ForStmt.parse();
}
```

5) `Stmt → Block`

```
{
  Block.parse();
}
```

6) `Stmt → DeclStmt ;`

```
{
  DeclStmt.parse();
}
```

7) `Stmt → ;`

```
{
  // empty statement
}
```

8) `Stmt → PrefixIncDec ;`

```
{
  PrefixIncDec.parse();
}
```

9) `Stmt → id IdStmtTail ;`

```
{
  IdStmtTail.in = id.lexeme;
  // IdStmtTail 的动作见其产生式
}
```

10) `IdStmtTail → IncDecOp`

```
{
  // 继承属性：IdStmtTail.in 是该语句的 id
  t = new_temp();
  if (IncDecOp == '++') emit('+', IdStmtTail.in, '1', t);
  if (IncDecOp == '--') emit('-', IdStmtTail.in, '1', t);
  emit('=', t, _, IdStmtTail.in);
}
```

11) `IdStmtTail → AssignOp Expr`

```
{
  // 继承属性：IdStmtTail.in 是该语句的 id
  if (AssignOp == '=') {
    emit('=', Expr.place, _, IdStmtTail.in);
  } else {
    t = new_temp();
    // '+=' / '-=' / '*=' / '/=' 映射为 '+' / '-' / '*' / '/'
    op = map(AssignOp);
    emit(op, IdStmtTail.in, Expr.place, t);
    emit('=', t, _, IdStmtTail.in);
  }
}
```

12) `PrefixIncDec → IncDecOp id`

```
{
  t = new_temp();
  if (IncDecOp == '++') emit('+', id.lexeme, '1', t);
  if (IncDecOp == '--') emit('-', id.lexeme, '1', t);
  emit('=', t, _, id.lexeme);
}
```

13) `AssignOp → = | += | -= | *= | /=`

```
{
  // no-op
}
```

14) `IncDecOp → ++ | --`

```
{
  // no-op
}
```

---

### 赋值表达式（AssignExpr：统一格式）

> 说明：这里把“赋值语句”的核心语义单独抽出来写成 `AssignExpr`，与代码里的 `RDParser._assign_expr()` 一致。
>
> 记号约定：四元式 `emit(op, a1, a2, res)` 里不用的参数用 `_` 表示。

15) `AssignExpr → id = Expr`

```
{
    emit('=', Expr.place, _, id.lexeme);
    AssignExpr.place = id.lexeme;
}
```

16) `AssignExpr → id += Expr`

```
{
    t = new_temp();
    emit('+', id.lexeme, Expr.place, t);
    emit('=', t, _, id.lexeme);
    AssignExpr.place = id.lexeme;
}
```

> 备注：`-=` / `*=` / `/=` 与 `+=` 同构，只需把 `+` 换成对应算术运算符。

---

### for 语句（统一格式：控制流 + 条件/迭代可选）

17) `ForStmt → for ( Init ; Cond ; Iter ) Stmt`

```
{
    // Init：进入循环前执行一次
    if (Init != ε) Init.parse();

    L_begin = new_label();
    L_end = new_label();
    emit('label', _, _, L_begin);

    // Cond：每轮循环开始处判断
    if (Cond != ε) emit('ifFalse', Cond.place, _, L_end);

    Stmt.parse();

    // Iter：每轮循环体后执行
    if (Iter != ε) Iter.parse();

    emit('goto', _, _, L_begin);
    emit('label', _, _, L_end);
}
```

18) `Init → DeclStmt | PrefixIncDec | AssignExpr | ε`

```
{
    // 对应实现：ForInitOpt
    // 语义分别复用 DeclStmt / PrefixIncDec / AssignExpr；ε 为 no-op
}
```

19) `Cond → Expr | ε`

```
{
    // 对应实现：ForCondOpt
    // 若为 Expr：Cond.place = Expr.place
    // 若为 ε：不生成 ifFalse（视作恒真）
}
```

20) `Iter → PrefixIncDec | AssignExpr | ε`

```
{
    // 对应实现：ForIterOpt
    // 语义分别复用 PrefixIncDec / AssignExpr；ε 为 no-op
}
```

> 与实现细节的对应：当前 `RDParser._for_stmt()` 为了让 `Cond/Iter` 的四元式出现在正确位置，使用了 `_DeferredEmitter` 做“先缓冲、后 flush”。

---

### 表达式（place 综合属性 + 运算四元式）

  表达式优先级与你代码一致：Rel > Add > Mul > Unary > Primary。

**关系表达式（允许链式 relop）**

21) `Expr → AddExpr RelTail`

```
{
    RelTail.in = AddExpr.place;
    Expr.place = RelTail.place;
}
```

22) `RelTail → RelOp AddExpr RelTail1`

```
{
    t = new_temp();
    emit(RelOp.op, RelTail.in, AddExpr.place, t);
    RelTail1.in = t;
    RelTail.place = RelTail1.place;
}
```

23) `RelTail → ε`

```
{
    RelTail.place = RelTail.in;
}
```

**加法链**

24) `AddExpr → MulExpr AddTail`

```
{
    AddTail.in = MulExpr.place;
    AddExpr.place = AddTail.place;
}
```

25) `AddTail → AddOp MulExpr AddTail1`

```
{
    t = new_temp();
    emit(AddOp.op, AddTail.in, MulExpr.place, t);
    AddTail1.in = t;
    AddTail.place = AddTail1.place;
}
```

26) `AddTail → ε`

```
{
    AddTail.place = AddTail.in;
}
```

**乘法链**

27) `MulExpr → Unary MulTail`

```
{
    MulTail.in = Unary.place;
    MulExpr.place = MulTail.place;
}
```

28) `MulTail → MulOp Unary MulTail1`

```
{
    t = new_temp();
    emit(MulOp.op, MulTail.in, Unary.place, t);
    MulTail1.in = t;
    MulTail.place = MulTail1.place;
}
```

29) `MulTail → ε`

```
{
    MulTail.place = MulTail.in;
}
```

**一元表达式**

30) `Unary → UnaryOp Unary1`

```
{
  if (UnaryOp == '+') {
    Unary.place = Unary1.place;
  }
  if (UnaryOp == '-') {
    t = new_temp();
    emit('-', '0', Unary1.place, t);
    Unary.place = t;
  }
  if (UnaryOp == '!') {
    t = new_temp();
    emit('!', Unary1.place, _, t);
    Unary.place = t;
  }
}
```

31) `Unary → Primary`

```
{
  Unary.place = Primary.place;
}
```

**基本项**

32) `Primary → id`

```
{
    Primary.place = id.lexeme;
}
```

33) `Primary → num`

```
{
    Primary.place = num.lexeme;
}
```

34) `Primary → ( Expr )`

```
{
    Primary.place = Expr.place;
}
```

---

### 空语句 / 块

35) `Block → { StmtList }`

```
{
  // 仅包含内部语句的动作
}
```

36) `StmtList → Stmt StmtList | ε`

```
{
  // 常规语句序列：逐条执行 Stmt 的语义动作；ε 为 no-op
}
```

---

### 与代码对应的位置（语义部分）

* 表达式 place 返回值：`RDParser._expr/_add_expr/_mul_expr/_unary/_primary`
* 四元式输出：`self.emitter.emit(...)`，临时变量：`self.emitter.new_temp()`
* for 的控制流：`RDParser._for_stmt()`（`label/goto/ifFalse`，当前实现不使用 backpatch）
* 语句选择：`RDParser._stmt()`
